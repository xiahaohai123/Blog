# 整数二进制信息在计算机世界中的操作规则

## 二进制码的表示法

### 原码

一个数值的直接二进制表示形式即为原码，例如`6D = 0110B`，`-6D = 1110B`。

- 其中6为十进制值，0110为6对应的二进制值，也是6的原码。
- D表示十进制，B表示二进制。

### 反码

#### 正数

反码即为原码，例如6的反码也是0110

#### 负数

反码为原码的**非符号位**取反，例如-6的反码是1001。

### 补码

#### 正数

补码即为原码，例如6的补码是0110

#### 负数

补码为反码+1，例如-6的补码是1010

## 计算机世界中的整数存储法

**在计算机内存中，整数一律采用补码的形式来存储**

原因，计算机的硬件层实际上只有加法器，使用补码相加可以同时完成加法和减法的运算，与使用开销大减法器相比，电路大大简化了。

## 二进制扩展规则

## 数据类型升格扩展

例如byte类型升格到int类型，或者int类型升格到long类型。

- 扩展位置：此时在二进制的视角中，扩展出来的二进制位会放到高位。
- 填充规则：按照原始类型的符号位进行填充，符号位位1是新高位全部填充为1，符号位为0时新高位全部填充为0.

```java
class Test {
    public static void main(String[] args) {
        byte positiveA = 6; // 此时positiveA的二进制值为 0000 0110
        int positiveB = positiveA; // 此时positiveB的二进制值为 0000 0000 0000 0000 0000 0000 0000 0110

        byte negativeA = -6; // 此时negativeA的二进制值为 1111 1010，注意是补码
        int negativeB = negativeA; // 此时negativeB的二进制值为 1111 1111 1111 1111 1111 1111 1111 1010
    }
}
```

## 移位带来的扩展

常规情况下`0011 0100` 右移两位会变成 `0000 1101`
移位会带来两个问题。

1. 最后两个0哪里去了？会被舍弃。
2. 空缺的高位怎么填充？**接下来讲**。

### 带符号的移位

常见操作符号为`>>`

使用该移位符号进行移位时，空缺的高位填充值会依赖移位前的符号位。

- 符号位为0，即正数时，填充0。
- 符号位为1，即负数时，填充1。

```java
class Test {
    public static void main(String[] args) {
        int positiveA = 18;  // 0000 0000 0000 0000 0000 0000 0001 0010
        int a = 18 >> 2;  // a: 0000 0000 0000 0000 0000 0000 0000 0100

        int positiveB = -18;  // 1111 1111 1111 1111 1111 1111 1110 1110
        int b = -18 >> 2;  // b: 1111 1111 1111 1111 1111 1111 1111 1011
    }
}
```

### 无符号的移位

常见操作符号为`>>>`

使用该移位符号时，无论如何，填充位都会被填充为0。

```java
class Test {
    public static void main(String[] args) {
        int positiveA = 18;  // 0000 0000 0000 0000 0000 0000 0001 0010
        int a = 18 >>> 2; // a: 0000 0000 0000 0000 0000 0000 0000 0100

        int positiveB = -18;  // 1111 1111 1111 1111 1111 1111 1110 1110
        int b = -18 >>> 2; // b: 0011 1111 1111 1111 1111 1111 1111 1011
    }
}
```




