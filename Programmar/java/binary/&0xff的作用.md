# & 0xff的作用

## 正文

### 这个操作做了什么

#### 符号&

表示按位与，即一个实例，其在内存中以二进制存储的信息，每一个bit都与对应的数据进行与操作。

#### 0xff

在二进制中表示为`1111 1111`

#### & 0xff

表示一个实例中的二进制信息按位与`1111 1111`，会导致实例中仅剩下最后八位二进制数据，其他二进制位都置零。

### 作用

#### 取得低八位数据

1. 有时候我们需要截取一个数值类型`int/long`的最后八位二进制数据，可以使用`& 0xff`来达到目标。
2. 当然如果仅需要截取出一个`byte`类型，直接强制类型转换成`byte`也可以。
3. 我们有时候会遇到这么个情况，一个int类型的值，符号位为负数，我们需要取得第9到16为数据，此时，我们一般会先右移8位，再执行`& 0xff`以将多余的1置零来达到目标。

#### 数据类型扩展时，保证二进制位不变

通常用在我们只关心二进制的机器数而不关注十进制的值时。

- 数据类型从少字节扩展为多字节时，扩展部分该填1还是0？
    - 答案是根据符号位来填，符号位为1时(负数)，则扩展出来的高位全部填充1，反之则填充0。
    - 本质上就是符号位是什么就填充什么。

在符号位为1的场景时，我们对数据类型升格后，会多出大量被填充的1，如果我们不关心十进制的值而想要保留二进制的值，就需要`& 0xff`来保证二进制值不变。
注意，这么做了之后，十进制的值就变了。

```java
class test {
    private static int byte2int(byte[] src) {
        // &0xff保证补码一致性
        // 数值类型从小到大扩展时，扩展部分填充值为符号位，如果需要保证二进制值不变，则需要&0xff来将在负数情况下填充为1的扩展位置零
        int a = ((int) src[0] & 0xff) << 8;
        int b = src[1] & 0xff;
        return a + b;
    }
}
```

## 参考文献

1. [详解 & 0xff 的作用](https://blog.csdn.net/i6223671/article/details/88924481)