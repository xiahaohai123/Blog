
# 引言
笔者工作的第一家公司的产品在微观层面，是由大量组件拼凑而成的一个共同协作的系统。而这些组件在安装时的体现就是一个又一个组件安装包。在CentOS和Euler操作系统上，这些安装包的表现形式为rpm包。

没有用户喜欢在升级时，对着安装包清单去手动安装一个又一个组件安装包，更不用说用户可能还需要做一些额外的操作来变更环境上的配置。对用户来说，傻瓜式的一键安装升级包才是他们青睐的对象。

所以交付人一般会交付一个一键安装升级包给用户（测试），而这个升级包实际上也是交付人一步一步构建出来的。



# 构建升级包流程
这里仅讨论某战略客户场景下的tar升级包构建流程。



## 获取新版本的组件安装包

### 收集信息
交付人构建升级包前，需要知道哪些组件需要升级，而这些信息实际上来自于本次版本开发的研发人员，只有他们自己知道自己研发的功能要不要加入到升级包中，交付给测试进行测试。

所以交付人会准备一个交付文档，在大多数场景下为《提测更新包列表》文档。例如：xxx132-提测更新包列表。


### 构建组件安装包
我们公司的组件在代码合入后，需要去jenkins上构建升级包，某个组件第一次提测的情况下，一般需要做以下操作，以某个web组件为例：

1. 更改版本号
2. 在jenkins上，去对应分支的构建目录下，对对应组件条目点击构建。
3. 等待构建完成（最耗时的步骤）
4. 在仓库http://域名/yum/公司名/x86_64/Packages/下会有对应的安装包

## 构建一键安装升级包
升级包的目录结构
一般情况下，升级包目录结构如下所示

xxx-upgrade-版本号

|- bak

|- check_scripts

|- prebackup.sh

|- precheck.sh

|- old

|- 3proxy

|- common

|- guacamolerpm

|- gui

|- other

|- scripts

|- web_com

|- md5

|- packages

|- 3proxy

|- common

|- guacamolerpm

|- gui

|- other

|- scripts

|- <font style="color:blue">web_com</font>

|- <font style="color:green">upgrade</font>

|- upgrade.log

|路径|	作用|
|:-------:|:-----:|
|bak	|备份信息的路径，升级前会将需要备份的信息备份到该路径下，以备回滚需要。|
|check_scripts	|执行升级前的检查脚本存放路径。|
|old	|存放上一个版本的组件安装包，升级后回滚到上一个版本时会使用该目录下的组件安装包。|
|old/md5|	该升级包的回退用组件安装包MD5值列表，用以校验old目录内的组件安装包是否正确。|
|old/scripts|	用以存放上一个版本运行某些功能所需要的脚本类型文件。|
|packages|	存放新版本的组件安装包目录，升级时会使用该目录下的组件安装包。|
|packages/scripts|	用以存放新版本运行某些功能所需要的脚本类型文件。|
|upgrade|	升级脚本，用户仅需执行./uprage [install/uninstall]以升级到新版本或回滚到上一个版本|
|upgrade.log|	升级脚本的执行日志|

### 收集新安装包
构建者需要从仓库中将新的组件安装包下载下来，并存放在packages的正确目录中。

### 收集旧安装包
构建者需要从过去的升级包中将新的组件安装包对应的上一个版本的组件安装包一一找出，并存放在old的正确目录中。

更新md5文件，确保md5文件内的内容与old包内的组件安装包对应。

### 编写脚本
基于过去的脚本，修改得出能在该版本中使用的升级脚本。

### 构建升级包
tar cvf命令构建出升级包，该包以.tar结尾

### 验证
将该升级包放在每一个对应的环境上进行升级并验证。

验证升级是否正常，升级后组件是否都已安装。

验证回滚是否正常，回滚后的组件是否都已回退。

号召其他研发对研发内容进行验证。

### 交付
将升级包存放在rdfs服务器上，告知测试升级包存放路径。

至此，整个升级包的构建交付流程即算作结束。











