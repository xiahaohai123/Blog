# 自动打升级包系统设计

## 引言
手动打升级包的流程虽然不长，但非常容易出问题，主要来源于以下几点：
1. 每个环节都是由人来做的。众所周知，人工的东西容易出现各种变数，出现问题。假如打包人在打包期间身体不适，思路不清晰，就容易引入问题。
2. 最终环节，也就是验证升级包所需要的时间非常长。这意味着如果前面某一个环节出现变更，都要经历一遍长时间验证，这种枯燥的工作打包人来说是一种精神消磨，导致打包质量出现下降趋势。

鉴于打包流程实际上已经非常清晰，并且整个流程种大部分工作只是重复的机械劳动，所以人工完全可以被自动化流程所替代以解放打包人的生产力，让其有更多精力投入到开发中去。

## 部分关键概念
1. `CI/CD`，持续集成(Continuous Integration)，持续交付(Continuous Delivery)，持续部署(Continuous Deployment)。
2. `可重建`，在出现问题时可以快速销毁环境重新搭建。
  
## 升级包应该具备的特性
1. **一键升级**: 执行某一个脚本即可升级。
2. **支持回滚**: 升级后出现预料外的问题，可以快速回滚到上一个版本，以保证生产环境能继续投入使用
3. **增量升级**: 升级包内仅携带需要升级的组件和信息，其余不在该版本需要升级的组件，不会携带。

## 自动打包的思路
本次设计思路从始至终都有一个方针，用一个字形容就是“**懒**”，用一个词形容就是“**懒人化**”，高端一点形容就是“**最大化解放生产力**”。

所谓懒人化，就是傻瓜式，最好的结果就是我只需要点击一下某个按钮，剩下的事情都不用我做了，我只需要在这个时候摸摸鱼，惬意地喝杯茶，或者干些别的事情，等我回来，一切都已经准备就绪。
那么，我们开始吧~

### 拆解人的行为
具体的手动打包流程已经在文档[手动打包流程](./build_upgrade_package_manually.md)中写明，本篇会根据那一份文档分解出人的行为。

1. 收集需要更新的组件信息。
2. 根据需要更新的组件信息，去jenkins上手动构建用于升级的rpm包，jenkins会将成品rpm包存放于成品仓库。
3. 参考上一个版本的升级包，重新组件一个升级包目录结构，这种目录结构在整体上很相似，可能会由于新增了某些上个版本不需要升级的组件而新增一些目录，也可能会由于不需要升级上个版本升级过的某些组件而摘除一些目录。当然，不一定非得是我们的组件升级，非官方组件升级与某些脚本或配置文件的更新，也可能影响一些目录。
4. 从成品仓库中取出本次升级相关的rpm包，将他们一一放到对应的升级目录中。
5. 找出本次需要升级的组件对应的上一个版本组件rpm安装包，将他们一一放到对应的降级目录中，这一步是为了升级包有回滚能力打基础。
6. 编写升级脚本代码，确保每一个组件都能升级与降级。
7. 将整个升级包打包成tar包。
8. 构建或找出当前版本的纯净环境，即升级到最新版本后没有被使用过的环境，将升级包上传到该环境。
9. 验证升级能力与回滚能力。
10. 找研发团队进行集成自测。
11. 将升级包交付给测试团队。

### 哪些步骤仍然需要人来介入
1. 更新版本号
   1. 版本号是由人来定义的，它是作为最原始的入参，且版本号的变更虽然有规范，但主观性质更多，所以很难被自动化。
2. 脚本编写
   1. 其实大多数rpm的升级脚本是极其相似的，大部分只需要执行命令`rpm -Uvh --force xxx.rpm`
   2. 但是有些组件需要在`docker`内部升级，所以会需要多一些命令（理论上不该有这个操作，奈何公司没人维护DockerFile）。
   3. 另外某些组件升级后会需要重新加载服务`systemctl daemon-reload`，甚至重启。
   4. 有些特殊场景下，组件升级完后可能还需要进行一次安全加固，这些操作都需要一些**自定义**的命令。
   5. 增删文件的场景下，升级和降级的命令不一样。
   6. 但是仍然有降低手工成本的办法，组件都是使用rpm进行升级的，我们可以出一个大部分组件都能用的模板，需要自定义的可以通过该模板快速生成对应升级脚本代码。
3. 集成自测
   1. 集成自测在通常情况下没有可自动执行的测试用例，这里仍然可以使用比较传统的人工自测。
   2. *但是集成自测使用自动执行的测试用例理论上是可行的，可以作为一个课题*。
    
### 哪些步骤可以半自动化
1. 收集需要更新的组件信息
   1. 这一步看起来需要人来介入，但是根据CI/CD文章中，我发现jenkins可以观测gitlab上的代码库更新情况，并按情况自动构建。这一能力说明，在理论上构建器是能知道从时间A到时间B之间，更新了什么组件。那么理论上，构建器也能根据这些更新的组件信息组合构建出对应的升级包。
   2. 只能半自动化的理由是，升级包内不仅仅只有我们研发团队负责的组件升级，在某些版本上，我们可能需要升级第三方组件，或者更新配置文件或脚本。这种行为是无法通过观测代码库的变更来实现的，所以这部分信息需要手工提供。
2. 收集回滚用降级安装包
   1. 理论上该步骤只需要维护一个历代已发布安装包库即可为自动化提供基础，毕竟任务去数据库和仓库内找出对应的旧版本包即可。
   2. 但现实中，第三方rpm非常多，而降级的版本并非这么容易就能找到，相较于最开始就维护大而全的库，维护一个小而精的库是比较经济的选择。我们大可以在需要的时候，花一点点时间，完善一下数据库。
   3. 所以这里半自动化指的是，**降级包的库维护偶尔需要手工进行**，剩下的交给自动化代码即可。
3. 上传升级包到目标环境
   1. 上传过程是完全可以自动化的，但是上传过程启动时需要的入参需要由人来给出。
   2. 用以验证的环境也需要人来准备

### 哪些步骤可以完全自动化
1. 构建对应组件
   1. 公司内现有的jenkins能力为手工触发构建行为，但构建过程为完全自动化。手工触发构建行为在交互上看属于`HTTP`请求，那么只要是`HTTP`请求，理论上就能通过脚本发送请求来完成该任务，再不济，也能用selenium来模拟触发构建。
2. 重组升级包目录结构
   1. 每一个版本的升级包目录结构都是很相似的，从这一点我们可以得出，**升级包的迭代并不会影响目录的主体结构**，这一不变的部分，完全可以由代码代劳。
   2. 需要增加或摘除的目录怎么办？
      1. 在这一步前，收集需要更新的组件信息已经完成，可以根据该信息自动创建出适配的目录。
      2. 过去的升级包需要修剪的目录其实很多，原因是执行命令时大量使用了通配符，例如`rpm -Uvh --force packages/3proxy/*.rpm`，这意味着该目录下所有包都会被更新，但3proxy的更新还需要携带别的命令，例如`systemctl restart 3proxy`，因此，与3proxy配套的升级脚本就必须使用一个独立的目录。
      3. 通配符的使用反而限制了目录的通用性，所以我们可以移除通配符，毕竟在此之前，我们已经知道了我们具体要更新什么了，我们大可以让升级命令变成`rpm -Uvh --force packages/officialRpms/3proxy-0.9.3-1.rpm`。
      4. 这样，3proxy组件就可以和别的升级组件放置在同一个目录里，而该目录可以称之为官方升级组件。
      5. 取消掉通配符的使用会导致代码复用性变差，会徒增大量代码，但该场景下，我们或许不应该过于关注代码的复用性，而应该使升级脚本与升级组件一一对应，与其他组件独立互不影响，以此保证稳定。
      6. 当然，后续仍然可以为提高脚本代码的复用性作出努力。
      7. 按照笔者到写这篇文档为止的经验，升级包的升级领域目录下可以分为三大部分，第一方组件升级目录，第三方组件升级目录，第一方文件变更目录。
3. 将升级安装包文件放到对应的目录
   1. 信息充足的情况下，该步骤仅需要获取文件并放置到对应目录即可，自动化完全可行。
4. 打包成tar包
   1. 显而易见，一个命令的事情。
5. 验证升级与回滚
   1. 升级与回滚过程本质上只需要执行一次脚本就行，而验证标准可以采用`rpm -qi xxx`命令，检查构建时间和版本号来进行验证。
    
## Jenkins思路
### 前言
本来我想自己编写一个轮子去完成上述的所有操作，但是**闭门造车**不可取，所以我去看了下时下热门的CI/CD概念和Jenkins工具，也算是第一次接触到DevOps概念。

Jenkins里面有个概念叫pipeline，即流水线，一个流水线内可以完成任意事情，并且流水线还能配置执行完该流水线后继续执行其他流水线，这让复杂构建被拆分成一个个细小的任务成了可能。那么我其实也不用重复造轮子，尝试使用Jenkins来解决问题也不失为一种不错的选择。

### 已明确的Jenkins能帮我们做到的事

1. 持续交付（CD）
   1. 构建升级包其实主要分2个步骤，构建RPM与构建一键安装升级包。
   2. 这两大步骤刚好对应2种pipeline，构建RPM的pipeline与构建升级包的pipeline，并标记好上下游或配置好连携关系即可。
2. 自动构建RPM
   1. Jenkins可以检测代码库的变更，如果变更则自动执行一次构建，这个触发器将成为持续交付的核心动力源。
   
### 待解决的课题

1. 如何实现构建增量更新升级包？ 
   1. 构建升级包的pipeline需要有手段来保证本次构建的升级包不会有不需要更新的组件rpm，当有人对某个构建rpm包的pipeline点了一下手动构建，然而该pipeline对应的代码库其实并没有更新，也会触发构建升级包的pipeline，此时升级包的pipeline需要甄别需不需要将该rpm加入到升级包内.
2. 如何找到降级用的安装包？
   1. 降级用的安装包势必需要一个持久化信息库来维持，信息库怎么落地是一个问题。
   2. jenkins如何与信息库交互？
3. 版本号该如何控制？
   1. 每个组件都有自己的版本号，虽然大部分组件的版本号是通用的，但部分组件的版本号却是特立独行的。我们需要保证组件的版本号正确。
   2. 升级包的版本号也有可能会临时遭遇修改。
4. 非常规的临时升级包是否能兼容？
   1. 因为CI/CD并没有完善，我们公司没有持续测试，很容易出现一些旧版本的BUG，而客户又无法向上升级的情况，此时我们就需要出一个临时补丁包来满足客户的需要。
5. 第三方库的升级又该如何纳入自动化构建流程？
6. 是否能对已经打出来的确定已经发布了的升级包进行归档？
7. 公司项目里面没有Jenkinsfile，这意味着我需要自己维护Jenkinsfile，与项目分离，这种情况下如何监测代码库的更新情况？


### 以实践落地一个demo来研究jenkins
鉴于Jenkins的使用对我来说是全新的领域，与其过度思考，不如先完成一些可走通的demo来积累实践经验。通过这些经验，我或许可以发现更多、更好的解决方案。

所以我决定先完成一个简单的demo来扩充实践经验，demo相关的设计与实践不在这里详细赘述，可以通过以下链接去查看另一篇文档:
[Jenkins自动化流水线demo的设计与实践](design_and_practice_of_jenkins_demo.md)





## 参考文档
1. [What is CI/CD?](https://opensource.com/article/18/8/what-cicd)
2. [什么是持续集成（CI）/持续部署（CD）？](https://zhuanlan.zhihu.com/p/42286143)
3. [开始使用Jenkins](https://www.jenkins.io/zh/doc/pipeline/tour/getting-started/)
4. [手动打包流程](./build_upgrade_package_manually.md)
5. [Jenkins自动化流水线demo的设计与实践](design_and_practice_of_jenkins_demo.md)
