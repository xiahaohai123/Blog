# 前言

为了探索保证质量的开发方法，在某项目的某个版本开发中，我取出了一个独立的需求，尝试用TDD模式进行开发，最终结果并不理想，但我也获取了不少经验，在此进行一些总结。


# 什么是TDD？

**TDD**(Test Driven Development)，中译为测试驱动开发。意思如字面意义一样，由测试推动开发的进行，即先准备一些测试用例，这些测试用例综合起来，就可以描述一个功能的内容，研发只需要编写能通过所有测试用例的代码，即可完成功能的开发。

例如我们需要实现一个**除法器**，那么测试用例可以如下：

|被除数|除数|输出|
|-------|-------|-------|
|1|1|1|
|4|2|2|
|1|2|0.5|
|1|0|N/A|
|0|1|0|

然后研发编写一段程序（别耍小聪明用查表法），该程序能跑通如上测试用例，即可认为功能开发完成。

一个严谨的TDD流程应当包含以下三个步骤：
1. **RED**，程序无法跑通测试用例，即程序功能无法完成功能。
这种情况一般出现在测试用例刚刚编写完成，还没开始开发。
需求迭代，功能迭代，测试用例也一起迭代了，就好比除法器的功能要升级为计算器一样，**这意味着需要更多的测试用例去描述该程序**。
2. **GREEN**，程序能跑通测试用例了，意味着这个程序能顺利提供它应当提供的服务了。
研发修改程序直到能跑通所有测试用例后，就意味着进入了这一阶段。
3. **REFACTOR**，程序能用了并不代表结束，我们追求的不是当下完成了功能，而是写了一段优秀的代码，所以我们需要重构。
重构仍然需要依托测试用例，每次我们让代码更优美的修改，都可能**越界**（即无法跑通所有测试用例）
重构标准对每一个工程师来说可能都不一样，甚至在不同的场景下标准也不尽相同。

**在这里，测试用例即描述程序的语言。**

# TDD好在哪？

1. 最应当注意也是最重要的优点：**程序的质量由测试用例背书**，质量会直接和测试用例挂钩，只要测试用例足够完善，那么程序进入GREEN状态后，理论上就不会出现问题。
2. 对研发来说，它可以让研发以测试的视角审视程序，TDD是一个能让研发轻易发现自己编写的代码的漏洞的有力工具。研发再也不用担心自己编写代码一晃神导致多打一位数或者打错什么字而被测试提了一个故障，因为测试用例会保证研发程序的正确性。**这意味着程序里很难发生低级错误**。
3. 对测试来说，虽然我不知道测试是怎么看待研发写出来的程序的，但我相信他们也希望去测试一个有质量的程序，而不是总是被一些低级错误扰乱自己的思绪。
4. 对组织来说，程序高质量交付是组织能长久发展的基石。
5. 由熟练使用TDD的研发团队开发的程序，质量往往比非TDD的研发团队+测试团队高
	1. 很多隐含在代码间的问题，测试团队是无法测试也测试不出来的，不过白盒测试可能是例外。*我们其实经历过不少当期测试团队没测出来，但是在之后的某一轮需求迭代后，测试团队才发现了这个问题的情况。*
	2. 而TDD+开发规范可以减少代码间隐含的问题。
6. TDD能避免研发跳入**兔子洞的陷阱**，研发的功能开发是**有目标的**，即通关测试用例，也是**有依据的**，**他们知道自己怎么样才算完成了目标，即测试用例为研发的过程划定了范围**，这种情况下，功能开发的效率会提高。


# TDD的反面

1. 测试用例的编写是及其费时费力又费心的，TDD新手（我）体验一次功能复杂性高的测试用例编写，会感觉到很费心，而且存在大量的机械性重复性劳动（复制粘贴代码，更改用例），可能老手不会这样。你可能会发现测试用例代码的行数比功能代码更多。
2. **测试用例的维护也需要成本。**
	1. 功能迭代时，测试用例需要更新。
	2. 功能变化时，测试用例需要翻新。
	3. 顶层方案更改时，测试用例需要重写。
	4. 员工更替，熟悉测试用例需要时间。
3. 第1点是本人的主管感受，但是费时这个问题是真正客观存在的，在费时这件事上，我预估我（新手）用了一倍于开发的时间来编写测试用例。
4. 如果你把编写测试用例的预期时间加入到需求的工作量评估中，你的上头可能要找你谈话（笑）。
5. 另外，编写**好的测试用例**也是需要周密的思维与强大的想象力的，TDD最好的优点也**对编写测试用例的人提出了更难的挑战**。


# TDD优缺点综合总结

TDD在短期内会带来非常明显的缺点，比如产能下降，这问题公司肯定会密切关注，但是TDD在长期一定会带来更好的收益，随着代码质量的不断攀升，研发的开发习惯不断优化，后续的开发会越来越轻松，产能会回归，并且有比较高的可能性超过原有的产能，因为研发大概率不需要再为原有的技术债而头疼。

但是中国的大部分公司可能都要面临一个问题，岗位员工流动率不低，而TDD技能的熟练度是跟着个人的，这点会在一定程度上为TDD的实施带来阻力。



# 研发团队如何实施TDD？

和测试团队不一样，研发团队经常与代码打交道，而距离研发最近的测试用例，就是**单元测试**。实际上，我也是用单元测试来执行TDD的。

如果你会golang，或者有学习golang的打算，可以尝试使用golang完成一次tdd的demo，因为golang语言的设计本身就将测试这个过程纳入了考虑范围，如何学习golang和TDD我建议参考这本书[《Learn Go with tests》](https://studygolang.gitbook.io/learn-go-with-tests/)。
我们只需要在开始动手写代码前，写写好单元测试，然后编写能通过单元测试的代码就行。

注意，顺序很重要，**测试先行**，一旦你先启动了功能开发，再反过来写单元测试时，思路会受到已有的功能代码的影响，并且这种时候很容易觉得，**编写单元测试是无意义的**。

# 这一次需求经历了什么？

1. 最开始，我选定了一个方案，并立即执行了TDD开发，整个流程相当顺利，开发完成后我信誓旦旦的说，这一次测试将极难找出问题。
2. 但在我开发完后和老练的同事商量后，发现顶层方案是存在问题的。
	1. 文件的删除没有采用指定删除，而是使用了指定保留文件，删除其他所有文件，这意味着需要遍历文件目录，**当文件目录下的文件数量很庞大的时候，列出文件列表是很危险的，它可能导致OOM问题**。
3. 方案变更了，此次的方案变更可以对应上述的顶层方案更改，这意味着之前的测试用例大部分都废了，要重写，**而时间显然已经不允许了**。
4. 迫不得已，我放弃了TDD，不再管理测试用例，专注于直接开发功能。
5. 之后测试在方案部分又提出了一些问题，导致方案又有更新，还好，此时我已经抛弃了TDD，没有维护测试用例的包袱。

# 经验和教训

1. 研发实施的TDD属于代码开发层面，而在该层上方，还有方案这一层，TDD能保证代码和程序质量，但是架不住方案层的降维打击，**一旦方案层发生变动，TDD的代码开发层会付出高昂的代价**。
2. 如果下一次要执行TDD，一定要现在范围层（功能规格说明书）详细划定好功能的范围，详尽的描述功能，并附上相关的详细方案。接下来就是最重要的：把这份文档交给尽量多的相关人员传阅，进行充分的讨论和评估，确保之后不要出现顶层变动导致降维打击。
3. 已经开发好的代码想要引入TDD是极其困难的，所以我推荐开发新的组件，全新的代码时可以尝试引入TDD。